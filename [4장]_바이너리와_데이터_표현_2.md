# :fire: Ch4. 바이너리와 데이터 표현 2

## :one: 정수 오버플로

컴퓨터 메모리가 표현할 수 있는 저장공간이 부족한 계산은 오버플로를 발생시킨다.

### 📝 2진수 정수 오버플로

- 부호가 없는 오버플로 : 덧셈을 했을 때 결과 값이 작아지거나, 뺄셈을 했을 때 결과 값이 커지면 부호가 없는 오버플로가 발생했다는 의미다. 자리올림 또는 자리내림을 반영할 메모리 저장공간이 없어 생기는 형상이다.
- 부호가 있는 오버플로 : 불연속성이 가장 큰 양수와 가장 작은 음수가 만나는 곳에 존재한다. 오버플로는 그 사이에서 발생한다. 즉, 피연산자의 가장 중요한 비트와 계산 결과의 가장 중요한 비트를 비교하면 오버플로를 판별할 수 있다.
  - 덧셈에서 두 피연산자의 부호가 다르다 : 오버플로 발생하지 않는다. 결과값의 절대값은 두 피연산자의 절대값보다 클 수 없기 때문이다.
  - 덧셈에서 두 피연산자의 부호가 같다 : 그 경우 결과값의 부호 비트 또한 피연산자의 것과 같아야 하는데, 다를 경우 오버플로가 발생했다는 뜻이다. 

---

## :two: 비트와이즈 연산자

비트와이즈 연산자를 사용하면 논리 게이트의 동작을 비트 시퀀스에 직접 적용하며 연산을 할 수 있다.

### 📝 비트와이즈 AND

- 두 개의 입력 비트열 각 자리에 대해 해당 비트가 모두 1이면 1을 출력한다.
- 곱하기를 생각하면 된다.

### 📝 비트와이즈 OR

- 두 개의 입력 비트열 각 자리에 대해 해당 비트 중 하나가 1이면 1을 출력한다. 모두 0일 경우에만 0을 출력한다.
- 더하기를 생각하면 된다.

### 📝 비트와이즈 XOR

- 두 개의 입력 비트열 각 자리에 대해 해당 비트 중 한 비트만 1일 대 해당 자리에 1을 출력한다.
  
|A|B|A^B|
|:--:|:--:|:--:|
|0|0|0|
|0|1|1|
|1|0|1|
|1|1|0|

### 📝 비트와이즈 NOT

- 피연산자의 각 자리를 뒤집는다.

### 📝 비트 시프트

- 피연산자의 비트 위치를 왼쪽이나 오른쪽으로 옮기는 연산이다.
- 오른쪽 시프트
  - 논리적 오른쪽 시프트 : 부호가 없는 값에서 사용. 결과 값의 최상위 비트에 0을 덧붙인다.
  - 산술적 오른쪽 시프트 : 부호가 있는 값에서 사용. 시프트 하기 전 최상위 비트 값을 새로운 비트에 복사한다.

---

## :three: 정수 바이트 오더

시스템 하드웨어가 여러 바이트의 변수에 연속된 메모리 주소를 할당하는 방법.

- x86 CPU의 경우는 정수를, 연속된 주소의 작은 자리수의 바이트에서 큰 자리수의 바이트 순으로 저장한다. (리틀 엔디안)
- 빅 엔디안 : 리틀 엔디안의 반대 순서로 여러 바이트 정수를 저장한다.

예를 들어 0xAABBCCDD를 저장할 때, 아래 표와 같이 저장된다.
|메모리 주소|x|x+1|x+2|x+3|
|:--:|:--:|:--:|:--:|:--:|
|리틀 엔디안의 경우|DD|CC|BB|AA|
|빅 엔디안의 경우|AA|BB|CC|DD|

- 이 저장 방식은 프로그램이 서로 다른 머신 사이에서 통신할 때 영향을 미친다. (예: 네트워크 경유)

---

## :four: 2진수에서의 실수

- 메모리의 한계 때문에 실수 인코딩은 대략적인 값으로 저장되는수 밖에 없다. 따라서 반올림을 허용하지 않는 애플리케이션을 작성할 대는 주의해야한다.

### 📝 고정 소수점 표현

- 2진수 소수점의 위치를 고정하여 실수를 표현하는 방법을 말한다.
- 소수점이 고정된 탓에 일부 계산 결과가 잘릴 수도 있다(예: 0b000000.11 / 0b000010.00). 그러한 왜곡이 누적되면, 계산 결과가 매우 달라질 수도 있다.

### 📝 부동 소수점 표현

- 부동 소수점 표현의 부동은 不動이 아니라 浮動이다.
- 2진수 소수점의 위치를 인코딩하는 방법은 다양하지만, 대부분의 현대 하드웨어는 IEEE 754 표준에 따른다.
- IEEE 754에 따른 32비트 부동 소수점 수의 경우
  - 최상위 비트는 부호를 뜻한다.
  - 하위 23비트는 유효 숫자 영역이다.
    - 유효숫자 부분의 최상위 비트는 2^(-1)을 뜻한다.
    - 유효 숫자의 값은 ((유효 숫자 실제 계산 값) + 1)로 해석된다.
  - 나머지 8 비트들은 지수를 나타낸다.
    - 바이어스 값은 127이다.
    - 지수 파트의 값은 2^((지수 파트의 정수 값) - 127)로 계산되며, 이 값은 결과 값을 도출하는 과정에서 유효 숫자와 곱해진다.
  - 10진수 소수점을 옮기는 능력, 즉 유연성은 정밀도와 trade-off 관계이다.
