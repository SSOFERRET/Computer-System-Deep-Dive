# :fire: Ch5. 컴퓨터 아키텍처

- 컴퓨터 전체 하드웨어
- **컴퓨터 하드웨어의 디지털 프로세서 설계와 구현**

## :one: 현대 컴퓨팅 아키텍처의 기원

- 1930~1940년대에 2진 논리를 회로에 적용해 전자 스위치를 개발할 수 있음을 제시. 이것이 2진 컴퓨터 시스템과 대부분의 디지털 회로 설계로 이어짐.
### 📝 튜링 머신

- 최초의 논리적 컴퓨팅 머신. 당시 컴퓨터 머신의 의사 결정 문제에 솔루션이 없음을 증명하는 과정에서 탄생함.
- 봄베: 애니그마 머신의 암호 해독 기계
- 자동 컴퓨팅 엔진(ACE): 저장된 프로그램 컴퓨터.

### 📝 초기의 전기 컴퓨터

- ENIAC: 전기 수치 통합 및 계산기(Electronic Numerical Integrator and Computer). 현대 컴퓨터의 선조. 10진수 사용함.

### 📝 폰 노이만 아키텍처

- EDVAC: 전자 이산 변수 자동 컴퓨터(Electronic Discrete Variable Automatic Computer): 
  - 범용적인 2진수 컴퓨터.
  - 메모리 내장.
  - 전기로만 동작함.
  - 이의 아키텍처 설계가 폰 노이만 아키텍처라 불리우게 됨.

---

## :two: 폰 노이만 아키텍처

현대 컴퓨터의 기반 역할.

### 📝 5가지 주요 컴포넌트

1. 처리 장치: 프로그램 명령어 실행.───────────────────────────┬───>>  CPU
2. 제어 장치: 처리장치에서 프로그램 명령어를 실행하도록 주도.  ─────────┘
3. 기억 장치: 프로그램 데이터와 명령어 저장
4. 입력 장치: 프로그램 데이터와 명령어를 컴퓨터에 로딩, 프로그램 실행 시작.
5. 출력 장치: 프로그램 실행 결과를 저장하거나 수신.

이 장치들은 버스라는 통신 채널로 서로 연결되어 2진값을 주고 받는다. 데이터 전송, 메모리 주소, 장치 간의 제어를 위한 버스가 별도로 있다.

### 📝 CPU : 처리 장치와 제어 장치

프로그램 데이터를 대상으로 프로그램 명령어를 실행한다.

- **처리 장치**
  - 산술 논리 장치(ALU): 산술 연산 및 논리 연산 수행.
  - 레지스터: 작고 빠른 저장 장치. ALU에 의해 실행되는 프로그램 명령어와 데이터를 구분 없이 저장한다.
- **제어 장치**
  - 프로그램 명령을 메모리에서 읽는다. 
  - 처리 장치를 통해 명령어의 피연산자와 연산을 전달하여 프로그램 명령 실행.
  - 저장 장치 내장
    - 프로그램 카운터: 다음 명령어의 메모리 상태 저장
    - 명령어 레지스터: 현재 실행 중인 명령 저장

### 📝 기억 장치

- 여기서의 메모리는 CPU가 직접 접근하는 메모리. RAM.
- 프로그램 데이터와 명령어를 저장한다.

### 📝 입력 및 출력 장치

외부 세계와의 상호작용을 담당한다.

- 입력 장치: 사용자가 컴퓨터 외부에서 데이터를 얻도록 프로그래밍하는 장비.
- 출력 장치: 컴퓨터가 계산한 결과를 외부 세계로 돌려보개거나 내장 메모리 외부에 저장한다.

### 📝 폰 노이만 머신

폰 노이만 아키텍처를 구성하는 다섯 가지 장치는 아래와 같은 사이클을 구현한다.

Fetch → Decode → Execute → Store

--- 

## :three: 논리 게이트

디지털 회로의 빌딩 블록. 산술, 제어, 저장 기능을 구현한다.

### 📝 기본 논리 게이트 - AND, OR, NOT

아래 표는 AND, OR, NOT 게이트에 대한 진리표이며, 아래 그림은 회로 도면에서 사용되는 심볼이다.

![1](https://github.com/SSOFERRET/Computer-System-Deep-Dive/assets/148465774/2fc69749-3c34-4853-933a-b53cbfd3220e)

![2](https://github.com/SSOFERRET/Computer-System-Deep-Dive/assets/148465774/c049d067-a245-4f43-b4f2-d62175f08393)

위 게이트을 조합하므로써 논리 회로를 만들 수 있다.

### 📝 그 외 논리 게이트 - NAND, NOR, XOR

아래 표는 NAND, NOR, XOR 게이트에 대한 진리표이며, 아래 그림은 회로 도면에서 사용되는 심볼이다.

![3](https://github.com/SSOFERRET/Computer-System-Deep-Dive/assets/148465774/65078de3-6263-4758-b299-5f67095cedb7)

![4](https://github.com/SSOFERRET/Computer-System-Deep-Dive/assets/148465774/4b603d85-95c9-4dad-9e62-9b65b364f198)

--- 

## :four: 회로

- 디지털 회로는 하드웨어의 명령 셋 아키텍처(ISA)와 시스템 전체의 저장 및 제어 기능을 구현한다.
- 하위 회로와 논리게이트를 구성하여 어떤 기능을 구현했을 때 블랙박스로 추상화되며, 이는 또 다른 회로의 하위 회로가 될 수 있다.
- 회로 빌등 블록은 산술/논리, 제어, 저장 회로로 나뉜다.

### 📝 산술/논리 회로

- ISA의 산술 및 논리 명령을 구현한다.
- 프로세서의 산술 논리 장치(ALU)를 구성한다.
- CPU의 다른 기능 일부를 구현하기도 한다.(예: PC)
- 비트 연산자 비트열과 레지스터 값을 조합해 메모리 주소를 계산하는데 사용된다.
- 1비트 회로 설계 단계
  - 회로의 진리표 설계
  - 진리표를 사용해 입력값과 AND, OR, NOT 등을 조합하여 하나의 표현식을 작성한다.
  - 표현식을 논리 게이트의 나열로 바꾼다.

### 📝 제어 회로

- 시스템 전체에서 사용된다.
  - 프로그램 데이터에 대한 프로그램 명령의 실행
  - 저장소에 대한 데이터 읽기와 저장
  - 시스템의 하드웨어 장비 제어
- 예1) 멀티플렉서: 여러 입력값 중 하나를 선택하는 제어 회로. 명령어 피연산자의 값을 읽을 CPU 레지스터를 선택할 수 있다.
- 예2) 디멀티플렉서: 여러 출력값 중 하나를 선택하는 제어 회로.

### 📝 저장 회로

- 컴퓨터 메모리를 구성한다.
  - SRAM: 정적 RAM. CPU 레지스터 저장소와 온 칩 캐시 메모리 구현에 사용.
  - DRAM: 동적 RAM. 메인 메모리 저장소(RAM)로 사용한다.
 - 값을 저장하기 위해 하나의 피드백 루프를 포함함으로써 회로에 의해 해당 값이 유지된다. 그러한 회로의 기본 회로가 되는 것이, 1비트 값을 저장하는 래치이다.
  - RS래치: nand게이트 2개로 이루어진 래치. S입력과 R입력이 모두 1일 때 회로는 출력값을 계속 저장한다.
  - 게이티드 D 래치: RS래치에 회로를 추가하여 R과 S에서 입력값으로 동시에 0을 받지 않는다. D 입력값은 WE 입력값이 1일 때에만 래치에 저장된다.
  - CPU 레지스터: 여러 개의 1비트 저장 회로를 연결해 만들어진 멀티비트 저장 회로. 예를 들어 32개의 1비트 D래치를 연결하면 32비트 CPU 레지스터로 사용할 수 있다.

--- 

## :five: 프로세서 만들기: 종합하기

CPU, 중앙처리장치
- 폰 노이만 아키텍처의 처리와 제어 장치를 구현
- 프로그램 데이터에 대해 프로그램 명령어를 실행한다.

CPU의 주요 기능 컴포넌트
- 산술 논리 장치(ALU): 산술 및 논리 연산
- 범용 레지스터: 프로그램 데이터 저장
- 제어 회로 및 특수 목적용 레지스터: 명령어 실행 구현
- 클럭: CPU의 회로가 프로그램 명령을 실행하는 타이밍을 알려 실행하도록 함.

### 📝 ALU

- ALU의 입력 = opcode: ALU가 구현할 산술 연산의 정수 피연산자 값과 연산을 지정하는 명령.
- ALU의 출력 = 조건 코드: 결과값, 연산 결과에 대한 정보. 연산 결과가 음수인지, 0인지, 자리 올림이 있는지 등을 나타낸다.
- ALU의 구성: 여러 산술 및 논리 회로 와 1개의 멀티플렉서. MUX가 ALU의 결과값을 선택한다.

![5](https://github.com/SSOFERRET/Computer-System-Deep-Dive/assets/148465774/ef422b88-8c4a-461e-afd4-d67204960b26)

- ALU에 대한 opcode 입력값은 CPU가 실행하는 명령 비트열에서 온다. 아래 이미지에서 비트열의 형태를 확인할 수 있다. 이 때 피연산자 소스 비트열은 값 그 자체일 수도 있고, 메모리 주소일 수도 있다.

![6](https://github.com/SSOFERRET/Computer-System-Deep-Dive/assets/148465774/d6bac03c-17be-41a8-b6a3-44e968480f6a)

- ALU는 4가지 연산을 지원하기 때문에, opcode는 4가지 연산을 인코딩할 수 있도록 2비트로 구성되어있다.

### 📝 레지스터 파일

### 📝 CPU
