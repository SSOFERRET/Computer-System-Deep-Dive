# :fire: Ch4. 바이너리와 데이터 표현 1

**컴퓨터 시스템은 2진수로 모든 것을 표현한다.**

바이너리는 1비트 정보, 즉 2진수이다. 컴퓨터 시스템은 정보를 바이너리로 인코딩하여 저장한다. 숫자 뿐만 아니라, 비숫자적인 문자, 이미지, 오디오 등의 정보도 마찬가지이다. 

1바이트 = 8비트. 바이트는 컴퓨터 시스템의 메모리를 지정할 수 있는 가장 작은 단위이다.

현대 CPU는 전형적으로 하드웨어 설계에 따라 32비트나 64비트를 묶은 워드를 정의한다. 워드의 크기는 곧, 시스템의 하드웨어가 데이터를 
하나의 컴포넌트에서 다른 컴포넌트로 옮기는데 사용하는 기본 크기를 결정한다.

C언어에서 변수를 선언하면, C 컴파일러는 변수의 2진 표현에 대한 두가지 정보를 전달 받게 된다. 
- 변수에 할당된 비트 수
- 프로그램이 그 비트열을 해석하는 방법
이후 컴파일러는 변수에 같은 양의 메모리를 할당한다. 비트열의 의미를 해석하는 방법은 실행하는 프로그램이나 사람에 따라 달라지게 된다.

## :one: 숫자의 밑과 부호가 없는 정수

### 📝 unsigned 숫자
- 10진수는 사람이 인식하기에 편한 방식이다.
- 2진수는 숫자 앞에 '0b'가 붙는다. 데이터가 하드웨어에 저장되는 방식이다.
- 16진수는 숫자 앞에 '0x'가 붙는다. 16진수로써 긴 비트열을 간결하게 다룰 수 있다.

### 📝 저장 공간 제한
다음과 같은 이유로, 변수에 할당한 비트수를 선택하는건 필수적이다.
- 변수를 선언하면서 컴파일러에 변수 타입에 따라 필요한 메모리양을 전달한다.
- 하드웨어 저장 장치의 용량은 유한하다.
- 프로그램은 데이터를 한 저장 장치에서 다른 저장 장치로 옮긴다. 값이 커질수록 신호 전달이 복잡해진다.

정수 오버플로우 : 변수의 크기보다 큰 값을 저장하려고 할 때 발생한다. 

---

## :two: 부호가 있는 2진수 정수
부호가 있는 2진 숫자 인코딩에서는 비트열에서 가장 왼쪽에 있는 한 개의 비트, 즉 최상위 비트를 사용해 음수와 양수를 구분한다(the high order bit, the most significant bit).

2진수 인코딩 방법으로는 부호가 있는 수와 2의 보수가 있는데, 실질적으로 사용되는 방법은 후자 뿐이다.

### 📝 부호가 있는 수

최상위 비트를 명시적으로 부호 비트로 간주한다.
- 최상위 비트가 0 : 양수
- 최상위 비트가 1 : 음수

직관적이라는 장점은 있으나, 다음의 두 가지 단점 때문에 실질적으로 사용되고 있지는 않다.
- 0이 두 개가 있다(음수의 0, 양수의 0). 동일한 숫자를 비트 값이 다른 2개의 바이너리 비트열로 표현해야한다는 어려움이 생긴다.
- 음수값과 0 사이에 단절이 있다. 0b0000에 1을 더하면 오버플로우로 인해 0b0000으로 되돌아가는데, 부호가 있는 수라면 이 효과로 인해 -7+1을 0으로 만들어버리게 된다. 음수와 양수 사이를 오갈 때 매우 번거롭게 된다.

### 📝 2의 보수

최상위 비트가 부호 비트로 역할을 하되, 숫자 값 자체에도 영향을 미친다. 보수는 다음과 같이 계산된다.

> -(최상위 비트 자리수의 값) + (그 외 자리수의 값)

- 음수와 0 사이의 전환이 더 자연스러우며, 0을 나타내는 비트열이 하나뿐이다.

**2의 보수를 부정하는 방법**

모든 비트를 반전시킨 뒤 1을 더하면 된다. (예: 0b1010(-6) =(반전)=> 0b0101(5) =(+1) => 0b0110(6))

**부호 확장**

대상 숫자의 가장 중요한 비트를 원하는 길이가 될 때까지 반복해 늘리는 작업을 말한다. (필요 예: int와 short를 더할 때)
- 최상위 비트를 그 앞에 필요한 만큼 덧붙이면 된다.

---

## :three: 2진 정수 산술 연산

### 📝 덧셈

- 2의 보수나 부호 없는 수, 부호 있는 수 모두 기본적인 2진수 덧셈식으로 계산하면 된다.
- 자리올림에 의해 오버플로우가 발생할 수 있다.

### 📝 뺄셈
- CPU는 뺄셈을 실행하기보다, 덧셈 회로와 부정 회로를 사용하는 것이 더 낫다.

### 📝 곱셈과 나눗셈

- 곱셈 : 손으로 계산할 때와 같다. (한 번에 한 자리씩 곱한 후 한 자리 시프트)
- 나눗셈 : 손으로 계산할 때와 같다. 대부분의 언어에서는 소수점 아래 수를 버린다.



